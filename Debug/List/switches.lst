###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          16/Feb/2022  20:09:28
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\mwg22\OneDrive\Desktop\ECE306-Project\switches.c
#    Command line  =  
#        -f C:\Users\mwg22\AppData\Local\Temp\EWCF02.tmp
#        (C:\Users\mwg22\OneDrive\Desktop\ECE306-Project\switches.c -lC
#        C:\Users\mwg22\OneDrive\Desktop\ECE306-Project\Debug\List -o
#        C:\Users\mwg22\OneDrive\Desktop\ECE306-Project\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I
#        ./ --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\mwg22\OneDrive\Desktop\ECE306-Project\Debug\List\switches.lst
#    Object file   =  
#        C:\Users\mwg22\OneDrive\Desktop\ECE306-Project\Debug\Obj\switches.r43
#
###############################################################################

C:\Users\mwg22\OneDrive\Desktop\ECE306-Project\switches.c
      1          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x200
   \   union <unnamed> _A_PAIN_L
   \                     _A_PAIN_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x220
   \   union <unnamed> _A_PBIN_L
   \                     _A_PBIN_L:
   \   000000                DS8 2
      2          #include "functions.h"
      3          
      4          //------------------------------------------------------------------------------
      5          // Description: This function calls the individual Switch Functions
      6          //------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
      7          void Switches_Process(void){
   \                     Switches_Process:
      8            Switch1_Process();
   \   000000   ........     CALLA   #Switch1_Process
      9            Switch2_Process();
   \   000004   ........     CALLA   #Switch2_Process
     10          }
   \   000008   1001         RETA
     11          
     12          // Globals

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     13          int count_debounce_SW1 = 0;
   \                     count_debounce_SW1:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     14          int count_debounce_SW2 = 0;
   \                     count_debounce_SW2:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     15          bool okay_to_look_at_switch1 = true;
   \                     okay_to_look_at_switch1:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for okay_to_look_at_switch1>`

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     16          bool okay_to_look_at_switch2 = true;
   \                     okay_to_look_at_switch2:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for okay_to_look_at_switch2>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     17          unsigned int sw1_position = RELEASED;
   \                     sw1_position:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for sw1_position>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     18          unsigned int sw2_position = RELEASED;
   \                     sw2_position:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for sw2_position>`
     19          
     20          
     21          //------------------------------------------------------------------------------
     22          // Switch 1 Configurations
     23          //------------------------------------------------------------------------------

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          bool SW1_PRESSED = false;
   \                     SW1_PRESSED:
   \   000000                DS8 1

   \                                 In  segment CODE, align 2
     25          void Switch1_Process(void){
   \                     Switch1_Process:
     26            if (okay_to_look_at_switch1 && sw1_position){
   \   000000   C293....     CMP.B   #0x0, &okay_to_look_at_switch1
   \   000004   0E24         JEQ     ??Switch1_Process_0
   \   000006   8293....     CMP.W   #0x0, &sw1_position
   \   00000A   0B24         JEQ     ??Switch1_Process_0
     27              if (!(P4IN & SW1)){
   \   00000C   E2B32102     BIT.B   #0x2, &0x221
   \   000010   082C         JC      ??Switch1_Process_0
     28                sw1_position = PRESSED;
   \   000012   8243....     MOV.W   #0x0, &sw1_position
     29                okay_to_look_at_switch1 = false;
   \   000016   C243....     MOV.B   #0x0, &okay_to_look_at_switch1
     30                count_debounce_SW1 = DEBOUNCE_RESTART;
   \   00001A   8243....     MOV.W   #0x0, &count_debounce_SW1
     31                // do what you want with button press
     32                SW1_PRESSED = true;
   \   00001E   D243....     MOV.B   #0x1, &SW1_PRESSED
     33              }
     34            }
     35            if (count_debounce_SW1 <= DEBOUNCE_TIME){
   \                     ??Switch1_Process_0:
   \   000022   B290DD05.... CMP.W   #0x5dd, &count_debounce_SW1
   \   000028   0334         JGE     ??Switch1_Process_1
     36              count_debounce_SW1++;
   \   00002A   9253....     ADD.W   #0x1, &count_debounce_SW1
   \   00002E   1001         RETA
     37            } else {
     38              okay_to_look_at_switch1 = true;
   \                     ??Switch1_Process_1:
   \   000030   D243....     MOV.B   #0x1, &okay_to_look_at_switch1
     39                if (P4IN & SW1){
   \   000034   E2B32102     BIT.B   #0x2, &0x221
   \   000038   0228         JNC     ??Switch1_Process_2
     40                sw1_position = RELEASED;
   \   00003A   9243....     MOV.W   #0x1, &sw1_position
     41              }
     42            }
     43          }
   \                     ??Switch1_Process_2:
   \   00003E   1001         RETA
   \   000040                REQUIRE _A_PBIN_L
     44          
     45          //------------------------------------------------------------------------------
     46          // Switch 2 Configurations
     47          //------------------------------------------------------------------------------

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     48          bool SW2_PRESSED = false;
   \                     SW2_PRESSED:
   \   000000                DS8 1

   \                                 In  segment CODE, align 2
     49          void Switch2_Process(void){
   \                     Switch2_Process:
     50            if (okay_to_look_at_switch2 && sw2_position){
   \   000000   C293....     CMP.B   #0x0, &okay_to_look_at_switch2
   \   000004   0E24         JEQ     ??Switch2_Process_0
   \   000006   8293....     CMP.W   #0x0, &sw2_position
   \   00000A   0B24         JEQ     ??Switch2_Process_0
     51              if (!(P2IN & SW2)){
   \   00000C   F2B20102     BIT.B   #0x8, &0x201
   \   000010   082C         JC      ??Switch2_Process_0
     52                sw2_position = PRESSED;
   \   000012   8243....     MOV.W   #0x0, &sw2_position
     53                okay_to_look_at_switch2 = false;
   \   000016   C243....     MOV.B   #0x0, &okay_to_look_at_switch2
     54                count_debounce_SW2 = DEBOUNCE_RESTART;
   \   00001A   8243....     MOV.W   #0x0, &count_debounce_SW2
     55                // do what you want with button press
     56                SW2_PRESSED = true;
   \   00001E   D243....     MOV.B   #0x1, &SW2_PRESSED
     57              }
     58            }
     59            if (count_debounce_SW2 <= DEBOUNCE_TIME){
   \                     ??Switch2_Process_0:
   \   000022   B290DD05.... CMP.W   #0x5dd, &count_debounce_SW2
   \   000028   0334         JGE     ??Switch2_Process_1
     60              count_debounce_SW2++;
   \   00002A   9253....     ADD.W   #0x1, &count_debounce_SW2
   \   00002E   1001         RETA
     61            } else {
     62              okay_to_look_at_switch2 = true;
   \                     ??Switch2_Process_1:
   \   000030   D243....     MOV.B   #0x1, &okay_to_look_at_switch2
     63              if (P2IN & SW2){
   \   000034   F2B20102     BIT.B   #0x8, &0x201
   \   000038   0228         JNC     ??Switch2_Process_2
     64                sw2_position = RELEASED;
   \   00003A   9243....     MOV.W   #0x1, &sw2_position
     65              }
     66            }
     67          }
   \                     ??Switch2_Process_2:
   \   00003E   1001         RETA
   \   000040                REQUIRE _A_PAIN_L
     68          
     69          

   \                                 In  segment CODE, align 2
     70          bool get_sw1(void) {
   \                     get_sw1:
     71            if (SW1_PRESSED) {
   \   000000   C293....     CMP.B   #0x0, &SW1_PRESSED
   \   000004   0424         JEQ     ??get_sw1_0
     72              SW1_PRESSED = false;
   \   000006   C243....     MOV.B   #0x0, &SW1_PRESSED
     73              return true;
   \   00000A   5C43         MOV.B   #0x1, R12
   \   00000C   1001         RETA
     74            } else return false;
   \                     ??get_sw1_0:
   \   00000E   4C43         MOV.B   #0x0, R12
   \   000010   1001         RETA
     75          }
     76          
     77          

   \                                 In  segment CODE, align 2
     78          bool get_sw2(void) {
   \                     get_sw2:
     79            if (SW2_PRESSED) {
   \   000000   C293....     CMP.B   #0x0, &SW2_PRESSED
   \   000004   0424         JEQ     ??get_sw2_0
     80              SW2_PRESSED = false;
   \   000006   C243....     MOV.B   #0x0, &SW2_PRESSED
     81              return true;
   \   00000A   5C43         MOV.B   #0x1, R12
   \   00000C   1001         RETA
     82            } else return false;
   \                     ??get_sw2_0:
   \   00000E   4C43         MOV.B   #0x0, R12
   \   000010   1001         RETA
     83          }

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for okay_to_look_at_switch1>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for okay_to_look_at_switch2>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for sw1_position>`:
   \   000000   0100         DC16 1

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for sw2_position>`:
   \   000000   0100         DC16 1

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Switch1_Process
      4   Switch2_Process
      4   Switches_Process
        4   -> Switch1_Process
        4   -> Switch2_Process
      4   get_sw1
      4   get_sw2


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for okay_to_look_at_switch1>
       1  ?<Initializer for okay_to_look_at_switch2>
       2  ?<Initializer for sw1_position>
       2  ?<Initializer for sw2_position>
       1  SW1_PRESSED
       1  SW2_PRESSED
      64  Switch1_Process
      64  Switch2_Process
      10  Switches_Process
       2  _A_PAIN_L
       2  _A_PBIN_L
       2  count_debounce_SW1
       2  count_debounce_SW2
      18  get_sw1
      18  get_sw2
       1  okay_to_look_at_switch1
       1  okay_to_look_at_switch2
       2  sw1_position
       2  sw2_position

 
 174 bytes in segment CODE
   4 bytes in segment DATA16_AN
   6 bytes in segment DATA16_I
   6 bytes in segment DATA16_ID
   6 bytes in segment DATA16_Z
 
 174 bytes of CODE  memory
   6 bytes of CONST memory
  12 bytes of DATA  memory (+ 4 bytes shared)

Errors: none
Warnings: none
